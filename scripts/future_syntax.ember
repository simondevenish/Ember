//
// future_syntax.ember
//

// 1) Import a module and declare a module namespace
use "network.ember"

module epicAdventure {
  val START_GOLD = 10
}

// 2) Demonstrate creation vs. assignment
var isGameRunning: true    // Created with ':', initially true

// Additional global variables for our event example
var isNightTime: false
var monsterCount: 2

// Some small example objects (tables) that we'll mix in or reassign
var MagicalBeing: {
  castSpell: fn(spell) {
    print(this.name + " casts " + spell + "!")
  }
}

var InventorySystem: {
  checkInventory: fn() {
    print(this.name + " has => " + this.inventory)
  }
}

// Another object that might replace an existing mixin
var Explorer: {
  explore: fn() {
    print(this.name + " explores the unknown lands!")
  }
}

// A new table that might be *added* as a new mixin slot
var KnightBehavior: {
  defend: fn() {
    print(this.name + " raises a mighty shield to defend!")
  }
}

// 3) Create a player object using colon-syntax + initial mixin references
var player: {
  :[MagicalBeing, InventorySystem]  // Mix in MagicalBeing & InventorySystem
  name: "Adventurer"
  health: 50
  inventory: ["Sword", "Potion"]

  greet: fn() {
    print("Hello, I'm " + this.name)
  }

  // (A) Event-bound function: triggers on "NightAlarm" if isNightTime
  //     Chained filters => .filter("all").filter("name(Adventurer)")
  nightAlert: fn() <- [ "NightAlarm" { if isNightTime }.filter("all").filter("name(Adventurer)") ] {
    print("Player " + this.name + " reacts to the NightAlarm! It's dark!")
  }

  // (B) Another event-bound function for "MonsterAlert"
  //     Only triggers if monsterCount > 0, with a single filter "ofType(player)"
  monsterAlert: fn() <- [ "MonsterAlert" {
      if monsterCount > 0 { 
        print("Player sees monsterCount=" + monsterCount + ", so monsterAlert triggers.")
      }
    }.filter("ofType(player)") ] 
  {
    print("Player " + this.name + " readies for battle against monsters!")
  }
}

// A second object (townGuard) that also binds to the "NightAlarm" event
var townGuard: {
  name: "Town Guard"

  respondAtNight: fn() <- [ "NightAlarm" { if isNightTime }.filter("guards") ] {
    print("Guard " + this.name + " lights torches around the town!")
  }
}

// A free-floating event-bound function, triggered by "MonsterAlert" for all
fn monsterAlertGlobal() <- [ "MonsterAlert".filter("all") ] {
  print("A global event function: 'MonsterAlert' => entire region is on alert!")
}

// Basic usage with the existing mixins
player.greet()
player.checkInventory()
player.castSpell("Arcane Bolt")

// 4) Further demonstration of creation vs. assignment
var gold: 5
print("Gold initially => " + gold)

gold = 12
print("Gold after reassignment => " + gold)

// 5) Show reassigning the first mixin of 'player' to something else
//    (index 0 was originally MagicalBeing)
player[0] = Explorer

// Now 'player' no longer has castSpell, but it does have Explorer.explore
player.explore()

// 6) Add a brand new mixin at the next slot via '+:' operator
//    We had indexes [0]=Explorer, [1]=InventorySystem. Next slot is index=2.
player +: KnightBehavior
player.defend()  // from KnightBehavior

// 7) A “covered” iterator with break-out and filter
//    Collect squares of even numbers from 1..10, but stop if >= 8
let evenSquares = [
  (n*n): n: 1 to 11 {
    print("Visiting => " + n)
    if (n >= 8) {
      print("Reached 8 -> break!")
      break
    }
  }
  if (n % 2 == 0)  // filter out odd numbers
]
print("Collected even squares until 8 => " + evenSquares)

// 8) A “naked” iterator for side effects only
i: 0 to 3 {
  print("Day " + i + " => Foraging around camp...")
}

// 9) Demonstrate table assignment
var dayInfo: {
  weather: "sunny"
}
var secondDay: {
  weather: "rainy"
  event: "Found hidden treasure"
}

print("Day #1 => weather=" + dayInfo.weather)
dayInfo = secondDay
print("Now dayInfo => weather=" + dayInfo.weather + ", event=" + dayInfo.event)

// 10) Another “covered” iterator used purely for side effects on `player.health`
[
  step: 1 to 5 {
    player.health -= 10
    print("Step " + step + " => " + player.name + " has " + player.health + " HP")
    if (player.health <= 0) {
      print(player.name + " collapsed!")
      break
    }
  }
]

// 11) Demonstrate event *invocation*:

fn beginNight() {
  isNightTime = true
  print("[BEGIN NIGHT] isNightTime set to true.")
  // Now invoke the "NightAlarm" event with a condition block + extra filters
  ()->["NightAlarm" { if isNightTime }].filter("region(Town)").filter("someGroup") {
    print("[BEGIN NIGHT] Broadcasting NightAlarm in 'Town' for 'someGroup'!")
  }
}

fn monstersApproach() {
  print("Monsters are near! monsterCount => " + monsterCount)
  // Invoke "MonsterAlert" with a condition block + filter
  ()->["MonsterAlert" { if monsterCount > 0 }].filter("all") {
    print("[MONSTER ALERT] There is at least one monster nearby!")
  }
}

// 12) Putting it all together
print("=== Start of extended event usage ===")
beginNight()       // triggers "NightAlarm" => player.nightAlert & townGuard.respondAtNight 
monstersApproach() // triggers "MonsterAlert" => calls 'monsterAlert' on player + global function

print("[Decreasing monsterCount to 0 and trying again]")
monsterCount = 0
monstersApproach() // won't trigger player's monsterAlert because condition block checks monsterCount > 0

// End
print("=== End of future_syntax.ember ===")
