//
// future_syntax.ember
//

// One of my main objectives with this new syntax is to:
// 1. reduce the amount of typing required - I want to get to building things quicker, whilst code is readable. The goal is results not writing reams of complex code
// 2. less text to read - once familiar with the syntax and approach, easier to scan code files
// 3. Simplicity over complexity - Why write 10 lines of code when we can write 1
// 4. Greater trust in the programmer - as is evident with naked and covered iterators it is up to the programmer to define loop and conditional logic - no more do/while/for/for each.
//

// 1) Import a module and declare a module namespace (indentation style)
use "network.ember"

module epicAdventure:
  val START_GOLD: 10


// 2) Demonstrate creation vs. assignment
//    Using colon (':') for creation with initial value
//    Also show we can define function bodies with braces OR indentation
var isGameRunning: true   // Created with ':', initially true

// Show a small function defined with indentation-based body:
fn showGameState()
  if isGameRunning
    print("Game is running!")
  el
    print("Game is stopped...")

// And a function using braces:
fn toggleGameRunning() {
  isGameRunning = !isGameRunning
  print("Toggled isGameRunning => " + isGameRunning)
}

print("Initial game state => isGameRunning=" + isGameRunning)
showGameState()

toggleGameRunning()
showGameState()


// Additional global variables for our event example
// creation with colon-syntax
var isNightTime: false
var monsterCount: 2


// Some small example objects (tables) that we'll mix in or reassign
// (Indentation-based table syntax)
var MagicalBeing:
  castSpell: fn(spell)
    print(this.name + " casts " + spell + "!")


var InventorySystem:
  checkInventory: fn()
    print(this.name + " has => " + this.inventory)


// Another object that might replace an existing mixin
var Explorer:
  explore: fn()
    print(this.name + " explores the unknown lands!")


// A new table that might be *added* as a new mixin slot
var KnightBehavior:
  defend: fn()
    print(this.name + " raises a mighty shield to defend!")


// 3) Create a player object using colon-syntax + initial mixin references
//    Demonstrate indentation style, plus a portion with braces
var player:
  :[MagicalBeing, InventorySystem]  // Mix in MagicalBeing & InventorySystem
  name: "Adventurer"
  health: 50
  inventory: ["Sword", "Potion"]

  greet: fn()
    print("Hello, I'm " + this.name)

  // (A) Event-bound function: triggers on "NightAlarm" if isNightTime
  //     Chained filters => .filter("all").filter("name(Adventurer)")
  nightAlert: fn() <- [ "NightAlarm" { if isNightTime }.filter("all").filter("name(Adventurer)") ]
    // Using braces here for readability 
    {
      print("Player " + this.name + " reacts to the NightAlarm! It's dark!")
      if monsterCount > 0
        print("...and monsters are around to make it worse!")
      el
        print("No monsters in sight, but still spooky outside...")
    }

  // (B) Another event-bound function for "MonsterAlert"
  //     Only triggers if monsterCount > 0, with a single filter "ofType(player)"
  monsterAlert: fn() <- [ "MonsterAlert" {
      if monsterCount > 0 {
        print("Player sees monsterCount=" + monsterCount + ", so monsterAlert triggers.")
      }
    }.filter("ofType(player)") ]
  {
    print("Player " + this.name + " readies for battle against monsters!")
  }


// A second object (townGuard) that also binds to the "NightAlarm" event
// Indentation-based function block:
var townGuard:
  name: "Town Guard"

  respondAtNight: fn() <- [ "NightAlarm" { if isNightTime }.filter("guards") ]
    print("Guard " + this.name + " lights torches around the town!")


// A free-floating event-bound function, triggered by "MonsterAlert" for all
fn monsterAlertGlobal() <- [ "MonsterAlert".filter("all") ]
  print("A global event function: 'MonsterAlert' => entire region is on alert!")


// Basic usage with the existing mixins
player.greet()
player.checkInventory()
player.castSpell("Arcane Bolt")


// 4) Further demonstration of creation vs. assignment
var gold: 5
print("Gold initially => " + gold)

gold = 12
print("Gold after reassignment => " + gold)


// 5) Show reassigning the first mixin of 'player' to something else
//    (index 0 was originally MagicalBeing)
player[0] = Explorer

// Now 'player' no longer has castSpell, but it does have Explorer.explore
player.explore()


// 6) Add a brand new mixin at the next slot via '+:' operator
//    We had indexes [0]=Explorer, [1]=InventorySystem. Next slot is index=2.
player +: KnightBehavior
player.defend()  // from KnightBehavior


// 7) A “covered” iterator with break-out and filter
//    Collect squares of even numbers from 1..10, but stop if >= 8
let evenSquares = [
  (n*n): n: 1 to 11 {
    print("Visiting => " + n)
    if (n >= 8) {
      print("Reached 8 -> break!")
      break
    }
  }
  if (n % 2 == 0)  // filter out odd numbers
]
print("Collected even squares until 8 => " + evenSquares)


// 8) A “naked” iterator for side effects only (indentation-based block)
i: 0 to 3
  print("Day " + i + " => Foraging around camp...")


// 9) Demonstrate table assignment
var dayInfo:
  weather: "sunny"

var secondDay:
  weather: "rainy"
  event: "Found hidden treasure"

print("Day #1 => weather=" + dayInfo.weather)
dayInfo = secondDay
print("Now dayInfo => weather=" + dayInfo.weather + ", event=" + dayInfo.event)


// 10) Another “covered” iterator used purely for side effects on `player.health`
[
  step: 1 to 5 {
    player.health -= 10
    print("Step " + step + " => " + player.name + " has " + player.health + " HP")
    if (player.health <= 0) {
      print(player.name + " collapsed!")
      break
    }
  }
]


// 11) Demonstrate event *invocation*:

fn beginNight():
  isNightTime = true
  print("[BEGIN NIGHT] isNightTime set to true.")
  // Now invoke the "NightAlarm" event with a condition block + extra filters
  ()->["NightAlarm" { if isNightTime }].filter("region(Town)").filter("someGroup")
    print("[BEGIN NIGHT] Broadcasting NightAlarm in 'Town' for 'someGroup'!")


fn monstersApproach():
  print("Monsters are near! monsterCount => " + monsterCount)
  // Invoke "MonsterAlert" with a condition block + filter
  ()->["MonsterAlert" { if monsterCount > 0 }].filter("all") {
    print("[MONSTER ALERT] There is at least one monster nearby!")
  }


// 12) Putting it all together
print("=== Start of extended event usage ===")
beginNight()       // triggers "NightAlarm" => player.nightAlert & townGuard.respondAtNight 
monstersApproach() // triggers "MonsterAlert" => calls 'monsterAlert' on player + global function

print("[Decreasing monsterCount to 0 and trying again]")
monsterCount = 0
monstersApproach() // won't trigger player's monsterAlert because condition block checks monsterCount > 0


// 13) Demonstrate an async + coroutine function using <fn()> + `be` + `yield`
fn getData: <fn()>:
  be res: network.httpGet("https://example.com/endpointA")
  print("Response A => " + res)

  yield  // suspend the coroutine here (the function returns control to the runtime)
  print("Resuming getData after yield...")

  res = network.httpGet("https://example.com/endpointB")
  print("Response B => " + res)

// Call it:
print("=== Testing async + coroutine getData() ===")
getData()
print("Back from getData() — note that inside the function, we used `yield` so it might be resumed later...")


// End
print("=== End of future_syntax.ember ===")
