1. Variables & Data Types
Old Syntax (C-like)
js
Copy code
var x = 5;
let y = 10;
const z = "hello";
New Syntax (Minimal Adjustments)
We want to allow:

var x: 5 — Creates a variable x and assigns it 5.
let y: 10 — Creates an immutable reference y.
const z: "hello" — Creates a completely immutable constant z.
We could also omit var or let entirely and do x: 5.
Key Changes in the Parser / AST:

We no longer always see var x = 5;. Instead, we see var x: 5 or just x: 5.
We can keep the parser code for var let const (since it’s close). But internally, we need to allow a colon : instead of an equals sign.
Example: Instead of
js
Copy code
parse_variable_declaration(...) { 
    // expecting "var x = expr ;"
}
we might also allow
js
Copy code
// "var x : expr" or "x: expr" or "let x: expr"
We would change the grammar so that after we see var or let or const + an identifier, we look for a colon instead of an equals sign as the “assignment operator.”
Alternatively, for this first step, you might keep both forms:

var x = expr;
var x: expr;
Later, we remove the = usage entirely once the new syntax is stable.
Implementation Detail
In lexer.c, the colon : is recognized as punctuation (TOKEN_PUNCTUATION, value=":").
In parser.c, in parse_variable_declaration, after reading var and an identifier, we check for either a : or an = before the initializer expression.
2. Functions
Old Syntax (C-like)
js
Copy code
function greet(name) {
    print("Hello, " + name);
}
New Syntax (Minimal Adjustments)
We might define functions as:

js
Copy code
greet: fn(name)
  print("Hello, " + name)
or (brace style):

js
Copy code
greet: fn(name) {
    print("Hello, " + name);
}
Key Changes in the Parser / AST:

Instead of the keyword function greet(...), we do greet: fn(...).
We might remove the function keyword entirely from the grammar, or we keep it around for older scripts.
The parser logic that previously recognized function might now look for IDENTIFIER, followed by :, followed by fn(...).
We’d store the function name = greet and the parameters from inside parentheses.
Minimal Implementation Approach:

Keep AST node AST_FUNCTION_DEF but adapt the parse so that you do:
If the current token is IDENTIFIER followed by : followed by fn, parse as a function definition with that identifier’s name.
Then parse ( param1 , param2 ... ).
Then parse the function body either with indentation or braces.
3. Basic Iterators (Instead of for/while)
You mentioned new loop syntax like:

css
Copy code
i: 0 to 3
  print(i)
But let’s keep it simple for the initial pass:

We can internally compile your new loop syntax into the same AST nodes we already have (AST_FOR_LOOP or AST_WHILE_LOOP).
Parser: Instead of for (i = 0; i < 3; i++), we might see i: 0 to 3. The parser can translate that into a pseudo-for-loop with initialization (i = 0), condition (i < 3), increment (i = i + 1).
Implementation:

Add a new rule in parser.c: if we see IDENTIFIER : NUMBER to NUMBER, we create a new AST node of type “for-like”:
initializer => var i = start
condition => i < end
increment => i = i + 1
The block after that is the loop body (either indentation-based or braces).
Then existing logic can compile it as a normal for-loop.
Alternatively, if we want to keep for (...) { ... } for now (since you said to keep “the new syntax ignoring big new features”), we do not remove for/while just yet. We only mention we’ll soon add “naked iterator” or “covered iterator” in a future step.

4. Objects & Mixins (Coming Next)
You specifically said we want to move on to implementing objects and mixins next, so for now we do not incorporate them. But to prepare:

We might keep var hero: { name: "Alice", hp: 100 }.
The existing code already handles AST_ARRAY_LITERAL. We might add a new AST_OBJECT_LITERAL or re-purpose AST_INDEX_ACCESS for properties.
For mixins, we’d need a parser rule for hero: { :[SomeMixin, OtherMixin] name: "Alice" } or similar. Not in scope for this “basics” step, but that’s the direction.
Short Summary of Steps to Implement Basic New Syntax
Lexer

Recognize : as punctuation.
Possibly treat fn as a keyword or an identifier—decide which.
Parser

In parse_variable_declaration, allow both:
var <identifier> = <expr> (old)
var <identifier> : <expr> (new)
Possibly support an omitted var (just <identifier> : <expr>).
In parse_statement or a new function definition parse function calls for:
<identifier> : fn ( param1, param2 ) { body }
Or the indentation-based body if we want to keep it simple for now, we can parse it as if it were braces.
For basic new iterator syntax, we can do:
<identifier> : <start> to <end> { body }
This is internally turned into an AST_FOR_LOOP.
AST

We can keep the same node types but handle the new syntax in the parser so that we produce AST_VARIABLE_DECL, AST_FUNCTION_DEF, etc. from the new grammar.
The compiler/bytecode generator doesn’t care if the user typed var x : 5 vs var x = 5—it just sees AST_VARIABLE_DECL with an initializer.
Runtime or Bytecode

No major changes needed if your old logic for AST_VARIABLE_DECL, AST_FUNCTION_DEF, and AST_FOR_LOOP remains. The new syntax is purely a parser difference.
Objects & Mixins (later)

We will add an AST_OBJECT_LITERAL or reuse AST_ARRAY_LITERAL approach.
We’ll add “: [MixinA, MixinB]` support, in the parser.
Conclusion
In short, to move to the new syntax with minimal changes:

Adjust the parser to allow “colon-based variable creation” (x: 10) in place of var x = 10;.
Adjust the parser to parse myFunc: fn(param1) { ... } in place of function myFunc(param1) { ... }.
(Optionally) Introduce a “naked loop” or “covered loop” for basic iteration, but if you only want a small step, keep the existing for(...) or while(...). You can map i: 1 to 10 { ... } → an internal AST_FOR_LOOP.
Ignore advanced features (async, events, advanced comprehensions) for now.
This preserves the existing compiler (bytecode generation) and runtime logic. We mainly do parser changes plus some small lexical changes to accommodate the new syntax. Then, next steps can incorporate the bigger additions (objects, mixins, events, async, etc.).